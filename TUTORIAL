Getting Started
---------------

To use beanstalkc we have to import the library and set up a connection to a
beanstalkd server:

    >>> import beanstalkc
    >>> beanstalk = beanstalkc.Connection(host='localhost', port=14711)

If we leave out the `host` and/or `port` parameters, `'127.0.0.1'` and `11300`
would be used as defaults, respectively.


Basic Operation
---------------

Now that we have a connection set up, we can enqueue jobs:

    >>> beanstalk.put('hey!')
    1

Or we can request jobs:

    >>> job = beanstalk.reserve()
    >>> job.body
    'hey!'

Once we are done with processing a job, we have to mark it as done, otherwise
jobs are re-queued by beanstalkd after a "time to run" (120 seconds, per
default) is surpassed. A job is marked as done, by calling `delete`:

    >>> job.delete()

`reserve` blocks until a job is ready, possibly forever. If that is not desired,
we can invoke `reserve` with a timeout (in seconds) how long we want to wait to
receive a job. If such a `reserve` times out, it will return `None`:

    >>> beanstalk.reserve(timeout=0) is None
    True

If you use a timeout of 0, `reserve` will immediately return either a job or
`None`.


Tube Management
---------------

A single beanstalkd server can provide many different queues, called "tubes" in
beanstalkd. To see all available tubes:

    >>> beanstalk.tubes()
    ['default']

A beanstalkd client can choose one tube into which its job are put. This is the
tube "used" by the client. To see what tube you are currently using:

    >>> beanstalk.using()
    'default'

Unless told otherwise, a client uses the 'default' tube. If you want to use a
different tube:

    >>> beanstalk.use('foo')
    'foo'
    >>> beanstalk.using()
    'foo'

If you decide to use a tube, that does not yet exist, the tube is automatically
created by beanstalkd:

    >>> beanstalk.tubes()
    ['default', 'foo']

Of course, you can always switch back to the default tube. Tubes that don't have
any client using or watching, vanish automatically:

    >>> beanstalk.use('default')
    'default'
    >>> beanstalk.using()
    'default'
    >>> beanstalk.tubes()
    ['default']

Further, a beanstalkd client can choose many tubes to reserve jobs from. These
tubes are "watched" by the client. To see what tubes you are currently watching:

    >>> beanstalk.watching()
    ['default']

To watch an additional tube:

    >>> beanstalk.watch('bar')
    2
    >>> beanstalk.watching()
    ['default', 'bar']

As before, tubes that do not yet exist are created automatically once you start
watching them:

    >>> beanstalk.tubes()
    ['default', 'bar']

To stop watching a tube:

    >>> beanstalk.ignore('bar')
    1
    >>> beanstalk.watching()
    ['default']

You can't watch zero tubes. So if you try to ignore the last tube you are
watching, this is silently ignored:

    >>> beanstalk.ignore('default')
    1
    >>> beanstalk.watching()
    ['default']


Statistics
----------

Beanstalkd accumulates various statistics at the server, tube and job level.
Statistical details for a job can only be retrieved during the job's lifecycle.
So let's create another job:

    >>> beanstalk.put('ho?')
    2

    >>> job = beanstalk.reserve()

Now we retrieve job-level statistics:

    >>> from pprint import pprint
    >>> pprint(job.stats())
    {'age': 0,
     'buries': 0,
     'delay': 0,
     'id': 2,
     'kicks': 0,
     'pri': 2147483648,
     'releases': 0,
     'state': 'reserved',
     'time-left': 120,
     'timeouts': 0,
     'ttr': 120,
     'tube': 'default'}

If you try to access job stats after the job was deleted, you'll get a
`CommandFailed` exception:

    >>> job.delete()
    >>> job.stats()
    Traceback (most recent call last):
    ...
    CommandFailed: ('NOT_FOUND', [])

Let's have a look at some numbers for the `'default'` tube:

    >>> pprint(beanstalk.stats_tube('default'))
    {'current-jobs-buried': 0,
     'current-jobs-delayed': 0,
     'current-jobs-ready': 0,
     'current-jobs-reserved': 0,
     'current-jobs-urgent': 0,
     'current-using': 1,
     'current-waiting': 0,
     'current-watching': 1,
     'name': 'default',
     'total-jobs': 2}

Finally, there's an abundant amount of server-level statistics accessible via
the `Connection`'s `stats` method. We won't go into details here, but:

    >>> len(beanstalk.stats())
    40
