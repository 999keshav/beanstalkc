Handling of network errors in beanstalkc
========================================

    >>> import os, signal, threading, time
    >>> import beanstalkc

To get things going, we'll need to have a beanstalkd running:

    >>> def launch_beanstalkd():
    ...     pid = os.spawnlp(os.P_NOWAIT,
    ...                      'beanstalkd',
    ...                      'beanstalkd', '-l', '127.0.0.1', '-p', '14712')
    ...     time.sleep(1)
    ...     return pid

    >>> def kill_beanstalkd(pid):
    ...     os.kill(pid, signal.SIGTERM)
    ...     time.sleep(1)

    >>> pid = launch_beanstalkd()

Let's connect to this beanstalkd:

    >>> q = beanstalkc.Connection(port=14712)


`Connection#closed`
-------------------

Observe that we are now connected:

    >>> q.closed
    False

If we are connected, calling `Connection#connect` is a no-op:

    >>> q.stats()['total-connections']
    1

    >>> q.connect()
    >>> q.connect()
    >>> q.connect()

    >>> q.stats()['total-connections']
    1

_IMPORTANT NOTICE:_ The only guarantee regarding the `closed` attribute is that
when `closed == True`, the `beanstalkc.Connection` was either explicitly closed
or automatically closed due to socket errors. This means, that the `Connection`
is definitely not connected in any sense (i.e. neither are the underlying
Python `socket` or TCP connection). The observation that `closed == False` does
_not_ imply the converse, i.e. the `Connection` is not necessarily connected.
it typically only means that beanstalkc managed to successfully connect before
and has not been explicitly closed or encountered any socket error since.


Socket errors
-------------

    >>> class SimpleWorker(threading.Thread):
    ...     def __init__(self, conn):
    ...         threading.Thread.__init__(self)
    ...         self.conn = conn
    ...     def run(self):
    ...         try:
    ...             self.result = self.conn.reserve()
    ...         except beanstalkc.SocketError, e:
    ...             self.error = e

    >>> w = SimpleWorker(q)
    >>> w.start()

It may happen, that for whatever reason, the running beanstalkd dies:

    >>> kill_beanstalkd(pid)

This leads the pending `Connection#reserve` in our worker to throw a
`beanstalkc.SocketError`:

    >>> w.join()
    >>> raise w.error
    Traceback (most recent call last):
    ...
    SocketError...

The same is true for all kinds of networking-related error: beanstalkc wraps
all underlying socket errors in `beanstalkc.SocketError`. And as basically all
beanstalkc methods interact with the network this means that all methods may
throw `SocketError`s.

Finally, whitness that beanstalkc closes the connection if any socket errors
occur:

    >>> q.closed
    True


Epilogue
--------

Let's ensure we don't have stray beanstalkd's hanging around:

    >>> kill_beanstalkd(pid)
